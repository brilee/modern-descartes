Implementing the Game of Go (Part 1)
2016/8/23

In this essay, I'll talk about implementing the rules of Go in Python, starting with a naive implementation (Part 1), and then optimizing it to make play execution faster (Part 2).

Why do we care about the speed at which we can play moves in Go? In Chess, the [minimax algorithm](https://en.wikipedia.org/wiki/Minimax) is capable of exhaustively searching a game tree, and forms a good basis for a chess AI. In Go, the branching factor is much higher, making it impractical to implement a minimax algorithm. Monte Carlo tree search (MCTS) takes the alternate approach of semi-randomly playing out many possible continuations. Interestingly, MCTS converges to minimax as the number of playouts goes to infinity. The difference is that MCTS provides more useful results in the interim. Given that the number of playouts is extremely important to the quality of a MCTS-based AI, we are interested in churning through as many games of Go as possible in the shortest amount of time.

So let's start with our implementation! If you're not familiar with the rules of Go, see [this page for a quick introduction](http://senseis.xmp.net/?RulesOfGoIntroductory)

The Naive Implementation
------------------------

First, let's define some constants and utility functions.

    N = 19
    NN = N * N
    WHITE, BLACK, EMPTY = 'O', 'X', '.'

    def swap_colors(color):
        if color == BLACK:
            return WHITE
        elif color == WHITE:
            return BLACK
        else:
            return color

Next, let's decide on a board format. The obvious format would be a 2-dimensional NxN array, with coordinates as 2-tuples (x, y). Then, `board[x][y]` would return either `WHITE`, `BLACK`, or `EMPTY`. Unfortunately, this would lead to some ugly code in python: `board[coord[0]][coord[1]]`. So instead, we'll go with a 1-dimensional array of length N * N, so that we can use the much prettier `board[coord]`. Furthermore, since our stone colors are indicated by single characters, we can just use a string of length N * N to represent our board.

By using a string, we also get to avoid the slow `deepcopy` function, and immutability comes for free. To convert to/from flat coordinates, we'll define some helper functions:

    EMPTY_BOARD = EMPTY * NN

    def flatten(c):
        return N * c[0] + c[1]

    # Convention: coords that have been flattened have a "f" prefix
    def unflatten(fc):
        return divmod(fc, N)

We'll also want an easy way to find all the neighbors of a coordinate. Since this is a frequent computation, we'll just cache the results as a list of length N * N.

    def is_on_board(c):
        return c[0] % N == c[0] and c[1] % N == c[1]

    def get_valid_neighbors(fc):
        x, y = unflatten(fc)
        possible_neighbors = ((x+1, y), (x-1, y), (x, y+1), (x, y-1))
        return [flatten(n) for n in possible_neighbors if is_on_board(n)]

    # Neighbors are indexed by flat coordinates
    NEIGHBORS = [get_valid_neighbors(fc) for fc in range(NN)]
    assert sorted(NEIGHBORS[0]) == [1, N]
    assert sorted(NEIGHBORS[1]) == [0, 2, N+1]
    assert sorted(NEIGHBORS[N+1]) == [1, N, N+2, 2*N + 1]

Next, let's define the useful concept of "reach", as given in the Tromp-Taylor rules. The formal definition: "A point P, not colored C, is said to reach C, if there is a path of (vertically or horizontally) adjacent points of P's color from P to a point of color C." Another way to think about reach is the set of colors that neighbor a chain of stones.

Reach is a useful concept in two ways: we want to know if a chain of stones can reach an empty point (the capture rule), and we want to know if a chain of empty spaces reaches black, white, or both colors (for assigning territory at the end).

To deduce the reach of a stone, we use a flood-fill type algorithm to simultaneously discover the entire chain, as well as all of that chain's neighboring colors (the reach). We'll return both the chain and its reach, since both are useful.

    def unpack_bools(bool_array):
        return [i for i, b in enumerate(bool_array) if b]

    def find_reached(board, fc):
        color = board[fc]
        chain = [False] * NN; chain[fc] = True
        reached = set()
        frontier = [fc]
        while frontier:
            current_fc = frontier.pop()
            chain[current_fc] = True
            for fn in NEIGHBORS[current_fc]:
                if board[fn] == color and not chain[fn]:
                    frontier.append(fn)
                elif board[fn] != color:
                    reached.add(board[fn])
        return unpack_bools(chain), reached


Now, we're ready to implement basic moves! We have to place our stone, and handle any captures, prioritizing opponent captures over our own.

    class IllegalMove(Exception): pass

    def place_stone(color, board, fc):
        return board[:fc] + color + board[fc+1:]

    def bulk_place_stones(color, board, stones):
        byteboard = bytearray(board) # create mutable version of board
        for fstone in stones:
            byteboard[fstone] = color
        return str(byteboard) # and cast back to string when done

    def maybe_capture_stones(board, fc):
        chain, reached = find_reached(board, fc)
        if not EMPTY in reached:
            board = bulk_place_stones(EMPTY, board, chain)
            return board, chain
        else:
            return board, []

    def play_move_incomplete(board, fc, color):
        if board[fc] != EMPTY:
            raise IllegalMove
        board = place_stone(color, board, fc)

        opp_color = swap_colors(color)
        opp_stones = []
        my_stones = []
        for fn in NEIGHBORS[fc]:
            if board[fn] == color:
                my_stones.append(fn)
            elif board[fn] == opp_color:
                opp_stones.append(fn)

        for fs in opp_stones:
            board, _ = maybe_capture_stones(board, fs)

        for fs in my_stones:
            board, _ = maybe_capture_stones(board, fs)

        return board

But we're not done yet - recall that the ko rule prevents repeating board positions. Let's record a "ko" coordinate, which is either a flattened coordinate, or None (indicating that there is no ko to worry about). To bundle these two concepts together, we'll use python's handy namedtuple.

    class Position(namedtuple('Position', ['board', 'ko'])):
        @staticmethod
        def initial_state():
            return Position(board=EMPTY_BOARD, ko=None)

        def play_move():
            ...

        def score():
            ...

Detecting kos is actually quite easy: it's a position where exactly one stone was captured, and a takeback is possible. Takeback is possible if the move was played in a location that's already completely surrounded by one color. This intuition is captured in the `is_koish` function.

    def is_koish(board, fc):
        'Check if fc is surrounded on all sides by 1 color, and return that color'
        if board[fc] != EMPTY: return None
        neighbor_colors = {board[fn] for fn in NEIGHBORS[fc]}
        if len(neighbor_colors) == 1 and not EMPTY in neighbor_colors:
            return list(neighbor_colors)[0]
        else:
            return None

    class Position(namedtuple('Position', ['board', 'ko'])):
        ...
        def play_move(self, fc, color):
            board, ko = self
            if fc == ko or board[fc] != EMPTY:
                raise IllegalMove

            possible_ko_color = is_koish(board, fc)
            new_board = place_stone(color, board, fc)

            opp_color = swap_colors(color)
            opp_stones = []
            my_stones = []
            for fn in NEIGHBORS[fc]:
                if new_board[fn] == color:
                    my_stones.append(fn)
                elif new_board[fn] == opp_color:
                    opp_stones.append(fn)

            opp_captured = 0
            for fs in opp_stones:
                new_board, captured = maybe_capture_stones(new_board, fs)
                opp_captured += len(captured)

            for fs in my_stones:
                new_board, _ = maybe_capture_stones(new_board, fs)

            if opp_captured == 1 and possible_ko_color == opp_color:
                new_ko = fc
            else:
                new_ko = None

            return Position(new_board, new_ko)

That takes care of playing moves and detecting ko. To finish off our implementation, let's figure out how to score a board. We'll assume the Chinese scoring system, which allows you to play as many moves as you want to capture opponent stones within your own territory. Then, territory will simply be the number of stones, plus the number of empty intersections that only touch your own stones.

    class Position(namedtuple('Position', ['board', 'ko'])):
        ...
        ...
        def score(self):
            board = self.board
            while EMPTY in board:
                fempty = board.index(EMPTY)
                empties, border_colors = find_reached(board, fempty)
                if len(border_colors) == 1:
                    border_color = list(border_colors)[0]
                    board = bulk_place_stones(border_color, board, empties)
                else:
                    # if an empty intersection reaches both white and black,
                    # then it belongs to neither player. 
                    board = bulk_place_stones('?', board, empties)
            return board.count(BLACK) - board.count(WHITE)

Benchmarking this code, it appears that each move takes about 100 microseconds, on average, giving us 10,000 moves/sec. Given that the average full game is about 300 moves long, this naive implementation yields 30 games played per second. Some of the popular Go engines written in C are capable of ~10,000 games played per second - so clearly we have a long way to go! Assuming that python is about 10~100x slower than C, we can expect to harvest a 3x to 30x speed improvement with the right algorithms.

[Download the code here](/static/downloads/implementing_go_naive.py)
